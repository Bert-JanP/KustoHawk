[
    {
        "Name":  "Triggered alerts",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nAlertEvidence\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago({TimeFrame})\r\n| where EntityType == \u0027Machine\u0027\r\n| summarize arg_max(Timestamp, *) by AlertId\r\n| project AlertId\r\n| join kind=inner AlertInfo on AlertId\r\n| extend AlertLink = strcat(\u0027https://security.microsoft.com/alerts/\u0027, AlertId)\r\n| project-reorder Timestamp, Title, Category, Severity, DetectionSource, AlertLink\r\n| sort by Timestamp desc",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/XDR%20-%20DeviceAlerts.md",
        "ResultCount":  0
    },
    {
        "Name":  "Executable files in users public folder",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\n// The start of the folderpath in the Public directory.\r\nlet PublicFolder = @\u0027C:\\Users\\Public\u0027;\r\n// List with Executable File Extensions, can be adjusted or changed.\r\nlet ExecutableFileExtensions = dynamic([\u0027bat\u0027, \u0027cmd\u0027, \u0027com\u0027, \u0027cpl\u0027, \u0027ex\u0027, \u0027exe\u0027, \u0027jse\u0027, \u0027msc\u0027,\u0027ps1\u0027, \u0027reg\u0027, \u0027vb\u0027, \u0027vbe\u0027, \u0027ws\u0027, \u0027wsf\u0027, \u0027hta\u0027]);\r\n// Prevalence Threshold, if the file exceeds this threshold it is likely to be benign.\r\nlet FilePrevalenceThreshold = 250;\r\nDeviceFileEvents\r\n| where Timestamp \u003e ago({TimeFrame}) \r\n| where DeviceId =~ Device\r\n| where FolderPath contains PublicFolder\r\n// Extract File Extension from the filename.\r\n| extend FileExtension = tostring(extract(@\u0027.*\\.(.*)\u0027, 1, FileName))\r\n// Only list Files that are executable\r\n| where FileExtension in~ (ExecutableFileExtensions)\r\n| invoke FileProfile(\u0027SHA256\u0027, 10000)\r\n// Filter based on FilePrevalenceThreshold\r\n| where GlobalPrevalence \u003c= FilePrevalenceThreshold\r\n| project Timestamp, DeviceName, FileExtension, FolderPath, GlobalPrevalence, Signer, Publisher, ReportId, DeviceId",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/ExecutableFilesPublicFolder.md",
        "ResultCount":  0
    },
    {
        "Name":  "Executable files in ProgramData folder",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\n// The start of the folderpath in the Public directory.\r\nlet PublicFolder = @\u0027C:\\ProgramData\u0027;\r\n// List with Executable File Extensions, can be adjusted or changed.\r\nlet ExecutableFileExtensions = dynamic([\u0027bat\u0027, \u0027cmd\u0027, \u0027com\u0027, \u0027cpl\u0027, \u0027ex\u0027, \u0027exe\u0027, \u0027jse\u0027, \u0027msc\u0027,\u0027ps1\u0027, \u0027reg\u0027, \u0027vb\u0027, \u0027vbe\u0027, \u0027ws\u0027, \u0027wsf\u0027, \u0027hta\u0027]);\r\n// Prevalence Threshold, if the file exceeds this threshold it is likely to be benign.\r\nlet FilePrevalenceThreshold = 250;\r\nDeviceFileEvents\r\n| where Timestamp \u003e ago({TimeFrame}) \r\n| where DeviceId =~ Device\r\n| where FolderPath contains PublicFolder\r\n// Extract File Extension from the filename.\r\n| extend FileExtension = tostring(extract(@\u0027.*\\.(.*)\u0027, 1, FileName))\r\n// Only list Files that are executable\r\n| where FileExtension in~ (ExecutableFileExtensions)\r\n| invoke FileProfile(\u0027SHA256\u0027, 10000)\r\n// Filter based on FilePrevalenceThreshold\r\n| where GlobalPrevalence \u003c= FilePrevalenceThreshold\r\n| project Timestamp, DeviceName, FileExtension, FolderPath, GlobalPrevalence, Signer, Publisher, ReportId, DeviceId",
        "Source":  "tbd",
        "ResultCount":  0
    },
    {
        "Name":  "AMSI triggers",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nDeviceEvents \r\n| where Timestamp \u003e ago({TimeFrame}) \r\n| where ActionType == \u0027AmsiScriptDetection\u0027\r\n| where DeviceId =~ Device\r\n| extend Description = tostring(parse_json(AdditionalFields).Description) \r\n| project Timestamp, DeviceName, DeviceId, InitiatingProcessCommandLine, Description, ReportId",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/AMSIScriptDetections.md",
        "ResultCount":  0
    },
    {
        "Name":  "Active CISA known exploited vulnerabilities",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet KnowExploitesVulnsCISA = externaldata(cveID: string, vendorProject: string, product: string, vulnerabilityName: string, dateAdded: datetime, shortDescription: string, requiredAction: string, dueDate: datetime, notes: string)[\u0027https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv\u0027] with (format=\u0027csv\u0027, ignoreFirstRecord=True);\r\nDeviceTvmSoftwareVulnerabilities\r\n| where DeviceId =~ Device\r\n| project CveId\r\n| join kind=inner (KnowExploitesVulnsCISA | project cveID, vendorProject, product, vulnerabilityName, dateAdded) on $left.CveId == $right.cveID\r\n| project cveID, vendorProject, product, vulnerabilityName, dateAdded",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Vulnerability%20Management/CISAKnowExploitsVulnerabilitiesTotalVulnerableDevices.md",
        "ResultCount":  0
    },
    {
        "Name":  "Suspicious RunMRU registry key entries",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Parameters = dynamic([\u0027http\u0027, \u0027https\u0027, \u0027Encoded\u0027, \u0027EncodedCommand\u0027, \u0027-e\u0027, \u0027-eC\u0027, \u0027-enc\u0027, \u0027-w\u0027, \u0027iex\u0027]);\r\nlet Executables = dynamic([\u0027cmd\u0027, \u0027powershell\u0027, \u0027curl\u0027, \u0027mshta\u0027]);\r\nDeviceRegistryEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType == \u0027RegistryValueSet\u0027\r\n| where RegistryKey has \u0027RunMRU\u0027\r\n| where RegistryValueData has_any (Parameters) and RegistryValueData has_any (Executables)\r\n| project-reorder Timestamp, DeviceId, DeviceName, RegistryValueData, RegistryKey",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/SuspiciousRUNMRUEntry.md",
        "ResultCount":  0
    },
    {
        "Name":  "RMM tools with connections found",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet LOLRMM = externaldata(Name:string,Category:string,Description:string,Author:string,Date:datetime,LastModified:datetime,Website:string,Filename:string,OriginalFileName:string,PEDescription:string,Product:string,Privileges:string,Free:string,Verification:string,SupportedOS:string,Capabilities:string,\r\nVulnerabilities:string,InstallationPaths:string,Artifacts:string,Detections:string,References:string,Acknowledgement:string)[@\u0027https://lolrmm.io/api/rmm_tools.csv\u0027] with (format=\u0027csv\u0027, ignoreFirstRecord=True);\r\n// Exclude any allowed RMMs based on name, example: dynamic([\u0027Rapid7\u0027]);\r\nlet AllowedRMM_Name = dynamic([]);\r\n// Exclude any RMM based on executable name, example: dynamic([\u0027mstsc.exe\u0027, \u0027winscp.exe\u0027]), used by multiple rmms\r\nlet AllowedRMM_executable = dynamic([\u0027mstsc.exe\u0027]);\r\nlet ParsedExecutables = LOLRMM\r\n    | where Name !in~ (AllowedRMM_Name)\r\n    | distinct InstallationPaths\r\n    | extend FileNames = extract_all(@\u0027\b([a-zA-Z0-9 _-]+\\.exe)\u0027, InstallationPaths)\r\n    | mv-expand FileNames to typeof(string)\r\n    | where isnotempty(FileNames)\r\n    | project FileNames = tolower(FileNames)\r\n    | distinct FileNames\r\n    | where FileNames !in (AllowedRMM_executable);\r\nDeviceNetworkEvents\r\n| where DeviceId =~ DeviceId\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where tolower(InitiatingProcessFileName) in (ParsedExecutables)\r\n| where ActionType == \u0027ConnectionSuccess\u0027\r\n| project-reorder Timestamp, InitiatingProcessFolderPath, InitiatingProcessAccountUpn, RemotePort, RemoteIP",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/Living%20Off%20The%20Land/RMMConnection.md",
        "ResultCount":  0
    },
    {
        "Name":  "Inbound connections from public ip",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nDeviceNetworkEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n// Only list accepted inbound connections\r\n| where ActionType == \u0027InboundConnectionAccepted\u0027\r\n// Remove comment below if you only want to see inbound connections from public IP addresses.\r\n| where RemoteIPType == \u0027Public\u0027\r\n// Enrich IP information\r\n| extend GeoIPInfo = geo_info_from_ip_address(RemoteIP)\r\n| extend country = tostring(parse_json(GeoIPInfo).country), state = tostring(parse_json(GeoIPInfo).state), city = tostring(parse_json(GeoIPInfo).city), latitude = tostring(parse_json(GeoIPInfo).latitude), longitude = tostring(parse_json(GeoIPInfo).longitude)\r\n| project Timestamp, DeviceName, RemoteIP, RemotePort, LocalIP, LocalPort, country, state",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20InboundConnectionsCompromisedDevice.md",
        "ResultCount":  0
    },
    {
        "Name":  "ASR events (excluding AsrLsassCredentialTheft triggers)",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nDeviceEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ActionType startswith \u0027ASR\u0027 and ActionType !startswith \u0027AsrLsassCredentialTheft\u0027\r\n| project Timestamp,ActionType, FileName, FolderPath, ProcessCommandLine, InitiatingProcessCommandLine, AccountDomain, AccountName",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20ListMaliciousActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "SmartScreen triggers",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nDeviceEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ActionType in (\u0027SmartScreenAppWarning\u0027, \u0027SmartScreenUrlWarning\u0027)\r\n| extend SmartScreenTrigger = iff(ActionType == \u0027SmartScreenUrlWarning\u0027, RemoteUrl, FileName), ReasonForTrigger = parse_json(AdditionalFields).Experience\r\n| project Timestamp, DeviceName, ActionType, SmartScreenTrigger, ReasonForTrigger, InitiatingProcessCommandLine",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20ListMaliciousActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "Antivirus events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nDeviceEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ActionType == \u0027AntivirusDetection\u0027\r\n| extend ThreatName = tostring(parse_json(AdditionalFields).ThreatName)\r\n| project Timestamp, DeviceName, ActionType, ThreatName, FileName, FolderPath, SHA1, InitiatingProcessAccountSid",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20ListMaliciousActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "Tampering attempts",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nDeviceEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ActionType == \u0027TamperingAttempt\u0027\r\n| extend TamperingAction = tostring(parse_json(AdditionalFields).TamperingAction), Status = tostring(parse_json(AdditionalFields).Status), Target = tostring(parse_json(AdditionalFields).Target)\r\n| project Timestamp, DeviceName, ActionType, TamperingAction, Status, Target, InitiatingProcessCommandLine",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20ListMaliciousActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "Exploit Guard events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nDeviceEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ActionType startswith \u0027ExploitGuard\u0027\r\n| project Timestamp, DeviceName, ActionType, FileName, FolderPath, RemoteUrl, InitiatingProcessCommandLine",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20ListMaliciousActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "Registry Run and RunOnce events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet GlobalPrevalanceThreshold = 1000;\r\nlet windowsShells = dynamic([\u0027powershell.exe\u0027, \u0027powershell_ise.exe\u0027, \u0027cmd.exe\u0027, \u0027pwsh.exe\u0027, \u0027wscript.exe\u0027, \u0027cscript.exe\u0027, \u0027mshta.exe\u0027, \u0027rundll32.exe\u0027]);\r\nDeviceRegistryEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where RegistryKey endswith @\u0027\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0027 or  RegistryKey endswith @\u0027\\Microsoft\\Windows\\CurrentVersion\\RunOnce\u0027\r\n| invoke FileProfile(InitiatingProcessSHA256) \r\n| where GlobalPrevalence \u003c= GlobalPrevalanceThreshold or InitiatingProcessFileName in~ (windowsShells)\r\n| project-reorder Timestamp, ActionType, DeviceId, DeviceName, RegistryKey, PreviousRegistryValueData, InitiatingProcessCommandLine",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/DFIR/Defender%20For%20Endpoint/MDE%20-%20ListMaliciousActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "Suspicious browser child processes events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Browsers = dynamic([\u0027Chrome.exe\u0027, \u0027Firefox.exe\u0027, \u0027msedge.exe\u0027, \u0027Brave.exe\u0027]);\r\nlet SuspiciousChildProcesses = dynamic([\u0027cmd.exe\u0027, \u0027powershell.exe\u0027, \u0027bash.exe\u0027, \u0027csscript.exe\u0027, \u0027mshta.exe\u0027, \u0027msiexec.exe\u0027, \u0027rundll32.exe\u0027]);\r\nDeviceProcessEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where InitiatingProcessFileName in~ (Browsers)\r\n| where FileName in~ (SuspiciousChildProcesses) or ProcessVersionInfoOriginalFileName in~ (SuspiciousChildProcesses)\r\n| project  Timestamp, DeviceName, ProcessCommandLine, InitiatingProcessCommandLine, AccountUpn, ProcessVersionInfoOriginalFileName",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/SuspiciousBrowserChildProcess.md",
        "ResultCount":  0
    },
    {
        "Name":  "MSHTA events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Browsers = dynamic([\u0027Chrome.exe\u0027, \u0027Firefox.exe\u0027, \u0027msedge.exe\u0027, \u0027Brave.exe\u0027]);\r\nlet SuspiciousChildProcesses = dynamic([\u0027cmd.exe\u0027, \u0027powershell.exe\u0027, \u0027bash.exe\u0027, \u0027csscript.exe\u0027, \u0027mshta.exe\u0027, \u0027msiexec.exe\u0027, \u0027rundll32.exe\u0027]);\r\nDeviceProcessEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where InitiatingProcessFileName =~ \u0027mshta.exe\u0027 or ProcessVersionInfoOriginalFileName  =~ \u0027mshta.exe\u0027\r\n| project  Timestamp, DeviceName, ProcessCommandLine, InitiatingProcessCommandLine, AccountUpn, ProcessVersionInfoOriginalFileName",
        "Source":  "",
        "ResultCount":  0
    },
    {
        "Name":  "Anomalous SMB sessions identified",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Threshold = 25;\r\nDeviceNetworkEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ingestion_time() \u003e ago(1h)\r\n| where RemotePort == 445\r\n| summarize\r\n     TotalIpsAccessed = dcount(RemoteIP),\r\n     RemoteIPs = make_set(RemoteIP),\r\n     arg_max(Timestamp, *)\r\n     by DeviceName, bin(Timestamp, 15m)\r\n| where TotalIpsAccessed \u003e= Threshold \r\n| project Timestamp, DeviceName, InitiatingProcessCommandLine, InitiatingProcessAccountName, InitiatingProcessFolderPath",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/AnomalousSMBSessionsCreated.md",
        "ResultCount":  0
    },
    {
        "Name":  "EDR configuration discovery events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet ProcessBased = DeviceProcessEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where ProcessCommandLine has \u0027Get-MpPreference\u0027\r\n| extend Table = \u0027DeviceProcessEvents\u0027\r\n| project Table, Timestamp, DeviceName, ProcessCommandLine, InitiatingProcessCommandLine, InitiatingProcessFileName;\r\nlet EventBased = DeviceEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| extend Command = parse_json(AdditionalFields).Command\r\n| where Command has \u0027Get-MpPreference\u0027\r\n| extend ScriptLocation = extract(@\"literalPath \u0027(.*?)\u0027\", 0, InitiatingProcessCommandLine)\r\n| extend Table = \u0027DeviceEvents\u0027\r\n| project Table, Timestamp, DeviceName, ProcessCommandLine, InitiatingProcessCommandLine, InitiatingProcessParentFileName, ScriptLocation, Command;\r\nunion ProcessBased, EventBased",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/DefenderDiscoveryActivities.md",
        "ResultCount":  0
    },
    {
        "Name":  "Suspicious explorer child process events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Parameters = dynamic([\u0027http\u0027, \u0027https\u0027, \u0027Encoded\u0027, \u0027EncodedCommand\u0027, \u0027-e\u0027, \u0027-eC\u0027, \u0027-enc\u0027, \u0027-w\u0027, \u0027://\u0027, \u0027hidden\u0027, \u0027-h\u0027]);\r\nlet SuspiciousChildProcesses = dynamic([\u0027cmd.exe\u0027, \u0027powershell.exe\u0027, \u0027bash.exe\u0027, \u0027csscript.exe\u0027, \u0027mshta.exe\u0027, \u0027msiexec.exe\u0027, \u0027rundll32.exe\u0027]);\r\nDeviceProcessEvents\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where DeviceId =~ Device\r\n| where InitiatingProcessFileName =~ \u0027explorer.exe\u0027 or InitiatingProcessVersionInfoOriginalFileName =~ \u0027explorer.exe\u0027\r\n| where FileName in~ (SuspiciousChildProcesses) or ProcessVersionInfoOriginalFileName in~ (SuspiciousChildProcesses)\r\n| where ProcessCommandLine has_any (Parameters)\r\n| project Timestamp, DeviceName, ProcessCommandLine, InitiatingProcessCommandLine, AccountUpn, ProcessVersionInfoOriginalFileName",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/SuspiciousExplorerChildProcess.md",
        "ResultCount":  0
    },
    {
        "Name":  "New living of the land binary with external connection",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet LOLBins = dynamic([\u0027AppInstaller.exe\u0027, \u0027Aspnet_Compiler.exe\u0027, \u0027At.exe\u0027, \u0027Atbroker.exe\u0027, \u0027Bash.exe\u0027, \u0027Bitsadmin.exe\u0027, \u0027CertOC.exe\u0027, \u0027CertReq.exe\u0027, \u0027Certutil.exe\u0027, \u0027Cmd.exe\u0027, \u0027Cmdkey.exe\u0027, \u0027cmdl32.exe\u0027, \u0027Cmstp.exe\u0027, \u0027ConfigSecurityPolicy.exe\u0027, \u0027Conhost.exe\u0027, \u0027Control.exe\u0027, \u0027Csc.exe\u0027, \u0027Cscript.exe\u0027, \u0027CustomShellHost.exe\u0027, \u0027DataSvcUtil.exe\u0027, \u0027Desktopimgdownldr.exe\u0027, \u0027DeviceCredentialDeployment.exe\u0027, \u0027Dfsvc.exe\u0027, \u0027Diantz.exe\u0027, \u0027Diskshadow.exe\u0027, \u0027Dnscmd.exe\u0027, \u0027Esentutl.exe\u0027, \u0027Eventvwr.exe\u0027, \u0027Expand.exe\u0027, \u0027Explorer.exe\u0027, \u0027Extexport.exe\u0027, \u0027Extrac32.exe\u0027, \u0027Findstr.exe\u0027, \u0027Finger.exe\u0027, \u0027fltMC.exe\u0027, \u0027Forfiles.exe\u0027, \u0027Ftp.exe\u0027, \u0027Gpscript.exe\u0027, \u0027Hh.exe\u0027, \u0027IMEWDBLD.exe\u0027, \u0027Ie4uinit.exe\u0027, \u0027Ieexec.exe\u0027, \u0027Ilasm.exe\u0027, \u0027Infdefaultinstall.exe\u0027, \u0027Installutil.exe\u0027, \u0027Jsc.exe\u0027, \u0027Ldifde.exe\u0027, \u0027Makecab.exe\u0027, \u0027Mavinject.exe\u0027, \u0027Msedge.exe\u0027, \u0027Microsoft.Workflow.Compiler.exe\u0027, \u0027Mmc.exe\u0027, \u0027MpCmdRun.exe\u0027, \u0027Msbuild.exe\u0027, \u0027Msconfig.exe\u0027, \u0027Msdt.exe\u0027, \u0027Mshta.exe\u0027, \u0027Msiexec.exe\u0027, \u0027Netsh.exe\u0027, \u0027Odbcconf.exe\u0027, \u0027OfflineScannerShell.exe\u0027, \u0027OneDriveStandaloneUpdater.exe\u0027, \u0027Pcalua.exe\u0027, \u0027Pcwrun.exe\u0027, \u0027Pktmon.exe\u0027, \u0027Pnputil.exe\u0027, \u0027Presentationhost.exe\u0027, \u0027Print.exe\u0027, \u0027PrintBrm.exe\u0027, \u0027Psr.exe\u0027, \u0027Rasautou.exe\u0027, \u0027rdrleakdiag.exe\u0027, \u0027Reg.exe\u0027, \u0027Regasm.exe\u0027, \u0027Regedit.exe\u0027, \u0027Regini.exe\u0027, \u0027Register-cimprovider.exe\u0027, \u0027Regsvcs.exe\u0027, \u0027Regsvr32.exe\u0027, \u0027Replace.exe\u0027, \u0027Rpcping.exe\u0027, \u0027Rundll32.exe\u0027, \u0027Runexehelper.exe\u0027, \u0027Runonce.exe\u0027, \u0027Runscripthelper.exe\u0027, \u0027Sc.exe\u0027, \u0027Schtasks.exe\u0027, \u0027Scriptrunner.exe\u0027, \u0027Setres.exe\u0027, \u0027SettingSyncHost.exe\u0027, \u0027Stordiag.exe\u0027, \u0027SyncAppvPublishingServer.exe\u0027, \u0027Ttdinject.exe\u0027, \u0027Tttracer.exe\u0027, \u0027Unregmp2.exe\u0027, \u0027vbc.exe\u0027, \u0027Verclsid.exe\u0027, \u0027Wab.exe\u0027, \u0027winget.exe\u0027, \u0027Wlrmdr.exe\u0027, \u0027Wmic.exe\u0027, \u0027WorkFolders.exe\u0027, \u0027Wscript.exe\u0027, \u0027Wsreset.exe\u0027, \u0027wuauclt.exe\u0027, \u0027Xwizard.exe\u0027, \u0027fsutil.exe\u0027, \u0027wt.exe\u0027, \u0027GfxDownloadWrapper.exe\u0027, \u0027Advpack.dll\u0027, \u0027Desk.cpl\u0027, \u0027Dfshim.dll\u0027, \u0027Ieadvpack.dll\u0027, \u0027Ieframe.dll\u0027, \u0027Mshtml.dll\u0027, \u0027Pcwutl.dll\u0027, \u0027Setupapi.dll\u0027, \u0027Shdocvw.dll\u0027, \u0027Shell32.dll\u0027, \u0027Syssetup.dll\u0027, \u0027Url.dll\u0027, \u0027Zipfldr.dll\u0027, \u0027Comsvcs.dll\u0027, \u0027AccCheckConsole.exe\u0027, \u0027adplus.exe\u0027, \u0027AgentExecutor.exe\u0027, \u0027Appvlp.exe\u0027, \u0027Bginfo.exe\u0027, \u0027Cdb.exe\u0027, \u0027coregen.exe\u0027, \u0027Createdump.exe\u0027, \u0027csi.exe\u0027, \u0027DefaultPack.EXE\u0027, \u0027Devinit.exe\u0027]);\r\nlet ExcludedLolBins = dynamic([\u0027Msedge.exe\u0027]);\r\n// List all lolbins that have made remote connection to public IPs between the last 30 and 2 days.\r\nlet KnownRemoteLolbins =\r\nDeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp between (ago(30d) .. ago(TimeFrame))\r\n| where InitiatingProcessFileName in~ (LOLBins) and InitiatingProcessFileName !in~ (ExcludedLolBins)\r\n// Only list public IP actions.\r\n| where RemoteIPType == \u0027Public\u0027\r\n| distinct InitiatingProcessFileName;\r\nDeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n// Filter KnownRemoteLolbins\r\n| where InitiatingProcessFileName in~ (LOLBins) and InitiatingProcessFileName !in~ (ExcludedLolBins) and not(InitiatingProcessFileName in~ (KnownRemoteLolbins))\r\n| where RemoteIPType == \u0027Public\u0027\r\n// Enrich IP Information\r\n| extend GeoIPInfo = geo_info_from_ip_address(RemoteIP)\r\n| extend country = tostring(parse_json(GeoIPInfo).country), state = tostring(parse_json(GeoIPInfo).state), city = tostring(parse_json(GeoIPInfo).city), latitude = tostring(parse_json(GeoIPInfo).latitude), longitude = tostring(parse_json(GeoIPInfo).longitude)\r\n| project-reorder Timestamp, DeviceName, RemoteIP, InitiatingProcessFileName, InitiatingProcessCommandLine",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/Living%20Off%20The%20Land/NewLOLBinExternalConnection.md",
        "ResultCount":  0
    },
    {
        "Name":  "Suspicious NamedPipe events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet NamedPipes = externaldata(pipe_name: string, metadata_description: string, metadata_tool:string,  metadata_category: string, metadata_link: string, metadata_priority:string, metadata_fp_risk: string, metadata_severity: string, metadata_tool_type: string, metadata_usage: string, metadata_comment: string, metadata_reference: string)[@\u0027https://raw.githubusercontent.com/mthcht/awesome-lists/refs/heads/main/Lists/suspicious_named_pipe_list.csv\u0027] with (format=\u0027csv\u0027, ignoreFirstRecord=True);\r\nlet StandardizedPipes = NamedPipes\r\n    | project pipe_name = replace_string(tolower(pipe_name), \u0027*\u0027, \u0027\u0027);\r\nDeviceEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType == \u0027NamedPipeEvent\u0027\r\n| extend AdditionalFields_parsed = parse_json(AdditionalFields)\r\n| where split(tolower(AdditionalFields_parsed.PipeName), \u0027\\\\\u0027)[-1] has_any(StandardizedPipes)\r\n| extend PipeName = AdditionalFields_parsed.PipeName, PipeNameChild = split(tolower(AdditionalFields_parsed.PipeName), \u0027\\\\\u0027)[-1], FileOperation = AdditionalFields_parsed.FileOperation, NamedPipeEnd = AdditionalFields_parsed.NamedPipeEnd\r\n| project-reorder Timestamp, PipeName, FileOperation, DeviceName, AccountName, NamedPipeEnd",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Threat%20Hunting/Behaviour%20-%20SuspiciousNamedPipes.md",
        "ResultCount":  0
    },
    {
        "Name":  "Rare .lnk file created on desktop",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Threshold = 1000;\r\nDeviceEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType =~ \u0027ShellLinkCreateFileEvent\u0027\r\n| where FolderPath has \u0027Desktop\u0027\r\n| extend ShellLinkIconPath = parse_json(AdditionalFields).ShellLinkIconPath, ShellLinkWorkingDirectory = parse_json(AdditionalFields).ShellLinkWorkingDirectory\r\n// Enrich data with FileProfile\r\n| invoke FileProfile(InitiatingProcessSHA256, 10000)\r\n| where GlobalPrevalence \u003c= Threshold\r\n| project Timestamp, ActionType, FolderPath, ShellLinkIconPath, ShellLinkWorkingDirectory, InitiatingProcessAccountUpn",
        "Source":  "tbd",
        "ResultCount":  0
    },
    {
        "Name":  "Defender exclusion events",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet ExclusionOptions = dynamic([\u0027ExclusionPath\u0027, \u0027ExclusionExtension\u0027, \u0027ExclusionProcess\u0027, \u0027ExclusionIpAddress\u0027]);\r\nlet Modules = dynamic([\u0027Add-MpPreference\u0027,\u0027Set-MpPreference\u0027]);\r\nlet CommandLineExecutions = DeviceProcessEvents\r\n    | where DeviceId =~ Device\r\n    | where Timestamp \u003e ago(TimeFrame)\r\n    | where ProcessCommandLine has_any (Modules) and ProcessCommandLine has_any (ExclusionOptions);\r\nlet PowerShellExecutions = DeviceEvents\r\n    | where DeviceId =~ Device\r\n    | where Timestamp \u003e ago(TimeFrame)\r\n    | where ActionType == \u0027PowerShellCommand\u0027 \r\n    | where AdditionalFields  has_any (Modules) and AdditionalFields has_any (ExclusionOptions);\r\nunion PowerShellExecutions, CommandLineExecutions",
        "Source":  "tbd",
        "ResultCount":  0
    },
    {
        "Name":  "Scheduled tasks from AppData created or updated",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet Filters = dynamic([\u0027AppData\u0027, \u0027%localappdata%\u0027, \u0027%appdata%\u0027]);\r\nlet Exclusions = dynamic([@\u0027\\\\Microsoft\\\\OneDrive\\\\OneDriveStandaloneUpdater.exe\u0027, \u0027OneDriveLauncher.exe\u0027]);\r\nDeviceEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType in (\u0027ScheduledTaskCreated\u0027, \u0027ScheduledTaskUpdated\u0027)\r\n| where AdditionalFields has_any (Filters)\r\n| extend ParsedAdditionalFields = parse_json(AdditionalFields)\r\n| extend ScheduledTaskName = ParsedAdditionalFields.TaskName, Details = parse_json(ParsedAdditionalFields.TaskContent)\r\n| where not(Details has_any (Exclusions))\r\n| project-reorder Timestamp, DeviceName, ActionType, InitiatingProcessAccountUpn, ScheduledTaskName, Details",
        "Source":  "tbd",
        "ResultCount":  0
    },
    {
        "Name":  "Process primary token elevated to SeDebugPriv",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\n// Token elevated to SeDebugPriv\r\nlet SeDebugPriv = binary_shift_left(1, 20);\r\nDeviceEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType == \u0027ProcessPrimaryTokenModified\u0027\r\n| extend CurrentTokenPrivEnabled = tolong(parse_json(AdditionalFields).CurrentTokenPrivEnabled), OriginalTokenPrivEnabled = tolong(parse_json(AdditionalFields).OriginalTokenPrivEnabled)\r\n| extend PrivilegeDiff = binary_xor(OriginalTokenPrivEnabled, CurrentTokenPrivEnabled)\r\n| where PrivilegeDiff == SeDebugPriv\r\n| invoke FileProfile(InitiatingProcessSHA256)\r\n| project-reorder Timestamp, ActionType, InitiatingProcessFileName, InitiatingProcessSHA256, InitiatingProcessFolderPath, GlobalPrevalence, GlobalFirstSeen, InitiatingProcessCommandLine",
        "Source":  "tbd",
        "ResultCount":  0
    },
    {
        "Name":  "Potential beaconing activity",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet DeviceThreshold = 5;\r\nlet TimeFrame = {TimeFrame};\r\nlet ConnectionThreshold = 25;\r\nlet GlobalPrevalanceThreshold = 250;\r\nDeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where not(ipv4_is_private(RemoteIP))\r\n| where ActionType == \u0027ConnectionSuccessAggregatedReport\u0027\r\n| extend Connections = toint(parse_json(AdditionalFields).uniqueEventsAggregated)\r\n| summarize Total = count(), Devices = dcount(DeviceId), Domains = make_set(RemoteUrl), AvgConnections = avg(Connections) by RemoteIP, bin(TimeGenerated, 1d)\r\n| where AvgConnections \u003e= ConnectionThreshold and Devices \u003c= DeviceThreshold\r\n| join kind=inner (DeviceNetworkEvents\r\n    | where ActionType == \u0027ConnectionSuccess\u0027\r\n    | distinct RemoteIP, InitiatingProcessSHA256) on RemoteIP\r\n    | invoke FileProfile(InitiatingProcessSHA256)\r\n    | where GlobalPrevalence \u003c= GlobalPrevalanceThreshold",
        "Source":  "tbd",
        "ResultCount":  0
    },
    {
        "Name":  "Sliver C2 beacon loaded",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet ImageLoads = DeviceImageLoadEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType == \u0027ImageLoaded\u0027\r\n| where FileName =~ \u0027samlib.dll\u0027\r\n| where isnotempty(InitiatingProcessSHA256)\r\n| invoke FileProfile(InitiatingProcessSHA256, 1000)\r\n| where GlobalPrevalence \u003c= 50 or isempty(GlobalPrevalence)\r\n| project Timestamp, DeviceId, DeviceName, ActionType, FileName, InitiatingProcessFileName, InitiatingProcessSHA256, InitiatingProcessAccountSid, ReportId;\r\nlet NamedPipes = DeviceEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType == \u0027NamedPipeEvent\u0027\r\n| where isnotempty(InitiatingProcessSHA256)\r\n| join kind=inner (ImageLoads | distinct InitiatingProcessSHA256) on InitiatingProcessSHA256\r\n| where parse_json(AdditionalFields).PipeName == @\u0027\\Device\\NamedPipe\\wkssvc\u0027\r\n| project Timestamp, DeviceId, DeviceName, ActionType, FileName, InitiatingProcessFileName, InitiatingProcessSHA256, InitiatingProcessAccountSid, PipeName = parse_json(AdditionalFields).PipeName, ReportId;\r\nlet Connection = DeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where ActionType == \u0027ConnectionSuccess\u0027\r\n| where isnotempty(InitiatingProcessSHA256)\r\n| join kind=inner (ImageLoads | distinct InitiatingProcessSHA256) on InitiatingProcessSHA256\r\n| project Timestamp, DeviceId, DeviceName, ActionType, RemoteIP, RemoteUrl, InitiatingProcessFileName, InitiatingProcessSHA256, InitiatingProcessAccountSid, ReportId;\r\nunion NamedPipes, ImageLoads, Connection\r\n| sort by Timestamp asc, DeviceId, InitiatingProcessSHA256\r\n| scan with_match_id=Id declare (Step:string, Delta:timespan) with (\r\n    step InitialConnection: ActionType == \u0027ConnectionSuccess\u0027 =\u003e Step = \u0027s1\u0027;\r\n    step NamedPipe: ActionType == \u0027NamedPipeEvent\u0027 and DeviceId == InitialConnection.DeviceId and InitiatingProcessSHA256 == InitialConnection.InitiatingProcessSHA256 and Timestamp between (Timestamp .. datetime_add(\u0027second\u0027, 1, InitialConnection.Timestamp)) and InitiatingProcessAccountSid == InitialConnection.InitiatingProcessAccountSid =\u003e Step = \u0027s2\u0027, Delta = Timestamp - InitialConnection.Timestamp;\r\n    step ImageLoad: ActionType == \u0027ImageLoaded\u0027 and DeviceId == NamedPipe.DeviceId and InitiatingProcessSHA256 == NamedPipe.InitiatingProcessSHA256 and Timestamp between (Timestamp .. datetime_add(\u0027second\u0027, 1, NamedPipe.Timestamp)) and InitiatingProcessAccountSid == NamedPipe.InitiatingProcessAccountSid  =\u003e Step = \u0027s3\u0027, Delta = Timestamp - NamedPipe.Timestamp;\r\n)\r\n| where Step == \u0027s3\u0027",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Endpoint/SliverC2BeaconLoaded.md",
        "ResultCount":  0
    },
    {
        "Name":  "Abuse.ch ThreatFox malware domain hits",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet ThreatIntelFeed = externaldata(LineInfo: string)[\"https://threatfox.abuse.ch/downloads/hostfile/\"] with (format=\u0027txt\u0027, ignoreFirstRecord=True);\r\nlet IPRegex = \u0027[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\u0027;\r\nlet MalwareDomains = materialize (\r\n     ThreatIntelFeed\r\n     | where LineInfo matches regex IPRegex\r\n     | extend domain = extract(@\u0027127.0.0.1(.*)\u0027, 1 , LineInfo)\r\n     | distinct domain\r\n     | take 10000 // Max Size allowed\r\n     );\r\nDeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where RemoteUrl has_any (MalwareDomains)\r\n| project Timestamp, RemoteUrl, RemoteIP, DeviceName, InitiatingProcessCommandLine, InitiatingProcessFileName, InitiatingProcessAccountDomain, InitiatingProcessAccountName",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Threat%20Hunting/TI%20Feed%20-%20ThreatfoxMalwareDomains.md",
        "ResultCount":  0
    },
    {
        "Name":  "IP SUM (Level 4) hits",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\nlet ThreatIntelFeed = externaldata(DestIP: string)[@\u0027https://raw.githubusercontent.com/stamparm/ipsum/master/levels/4.txt\u0027] with (format=\u0027txt\u0027, ignoreFirstRecord=True);\r\nlet IPRegex = @\u0027[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\u0027;\r\nlet MaliciousIP = ThreatIntelFeed\r\n    | where DestIP matches regex IPRegex\r\n    | distinct DestIP;\r\nDeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where RemoteIP in (MaliciousIP)\r\n| extend GeoIPInfo = geo_info_from_ip_address(RemoteIP)\r\n| extend country = tostring(parse_json(GeoIPInfo).country), \r\n         state = tostring(parse_json(GeoIPInfo).state), \r\n         city = tostring(parse_json(GeoIPInfo).city), \r\n         latitude = tostring(parse_json(GeoIPInfo).latitude), \r\n         longitude = tostring(parse_json(GeoIPInfo).longitude)\r\n| project-reorder Timestamp, DeviceName, RemoteIP, RemotePort, InitiatingProcessAccountName",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Threat%20Hunting/TI%20Feed%20-%20MISP%20IPSum%20level%204.md",
        "ResultCount":  0
    },
    {
        "Name":  "Twitter IOC hits (@0xDanielLopez)",
        "Query":  "let Device = \u0027{DeviceId}\u0027;\r\nlet TimeFrame = {TimeFrame};\r\n// Collect external data from @0xDanielLopez Github. There is a UI for TweetFeed, this can be accessed on https://tweetfeed.live/\r\n// TweetFeed collects Indicators of Compromise (IOCs) shared by the infosec community at Twitter. Here you will find malicious URLs, domains, IPs, and SHA256/MD5 hashes.\r\n// Variables that are used:\r\n// Phishing and Spam IPs are most sensitive to false positves. Only enable this variable if you do want to include them.\r\nlet IncludeSpamPhishingIPS = false;\r\nlet TweetFeedLastMonth = externaldata(IOCTimestamp:datetime, TwitterUser:string, IOCType:string, IOC:string, IOCCatagory:string, TweetLink:string)[h@\u0027https://raw.githubusercontent.com/0xDanielLopez/TweetFeed/master/month.csv\u0027] with(format=\u0027csv\u0027);\r\n// Get overall statstics of the dataset.\r\nlet IOCStatistics = TweetFeedLastMonth\r\n| summarize Total = count() by IOCType;\r\n// All lines below are used to get lists of IOCs which can be mapped against tables. If you only want to use a some of those entries, remove the others for the best performance.\r\n// Collect IP IOCS and validate IP addresses. Variable for Phishing and Spam is used as defined above.\r\nlet IPEntries = TweetFeedLastMonth\r\n| where IOCType == \u0027ip\u0027\r\n| where not(IOCCatagory in (\u0027#phishing\u0027, \u0027#phishing #scam\u0027, \u0027#scam\u0027) and IncludeSpamPhishingIPS == false)\r\n| distinct IOC\r\n| where IOC matches regex \u0027[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\u0027;\r\n// Collect domain entries and make them lowercase.\r\nlet DomainEntries = TweetFeedLastMonth\r\n| where IOCType == \u0027domain\u0027\r\n| distinct tolower(IOC);\r\n// Collect domain entries and make them lowercase. remove all HTTP(S):// from the domain\r\nlet URLEntries = TweetFeedLastMonth\r\n| where IOCType == \u0027url\u0027\r\n| distinct IOC\r\n| extend StrippedDomain1 = extract(@\u0027////(.*)\u0027, 1, IOC);\r\n// Collect MD5 IOCS and validate md5 value\r\nlet MD5Entries = TweetFeedLastMonth\r\n| where IOCType == \u0027md5\u0027\r\n| distinct IOC\r\n| where IOC matches regex \u0027[a-f0-9]{32}\u0027;\r\n// Collect sha256 IOCS and validate sha256 value\r\nlet SHA256Entries = TweetFeedLastMonth\r\n| where IOCType == \u0027sha256\u0027\r\n| distinct IOC\r\n| where IOC matches regex \u0027[a-fA-F0-9]{64}\u0027;\r\n// The next lines will be used to search your tenant on the IOCs that are in the TweetFeed. This is done by combining multiple tables into one end result.\r\n// Lookups are used to gain additional information on the IOC\r\nunion isfuzzy=true\r\n// List IOC statistics\r\n// List IP IOC matches if they exsists.\r\n(DeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where RemoteIP in (IPEntries)\r\n| lookup kind=inner (TweetFeedLastMonth) on $left.RemoteIP == $right.IOC\r\n| extend GeoIPInfo = geo_info_from_ip_address(RemoteIP)\r\n| extend country = tostring(parse_json(GeoIPInfo).country), state = tostring(parse_json(GeoIPInfo).state), city = tostring(parse_json(GeoIPInfo).city), latitude = tostring(parse_json(GeoIPInfo).latitude), longitude = tostring(parse_json(GeoIPInfo).longitude)),\r\n// List domain IOC matches if they exsists.\r\n(DeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where RemoteUrl has_any (DomainEntries)\r\n| lookup kind=inner (TweetFeedLastMonth) on $left.RemoteUrl == $right.IOC),\r\n// List url IOC matches if they exsists.\r\n(DeviceNetworkEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where RemoteUrl in (URLEntries)\r\n| lookup kind=inner (TweetFeedLastMonth) on $left.RemoteUrl == $right.IOC),\r\n(DeviceFileEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where MD5 in (MD5Entries)\r\n| lookup kind=inner (TweetFeedLastMonth) on $left.MD5 == $right.IOC),\r\n(DeviceFileEvents\r\n| where DeviceId =~ Device\r\n| where Timestamp \u003e ago(TimeFrame)\r\n| where SHA256 in (SHA256Entries)\r\n| lookup kind=inner (TweetFeedLastMonth) on $left.SHA256 == $right.IOC)\r\n// Reorder columns to first get info on IOC\r\n| project-reorder IOCType, IOCTimestamp, IOCCatagory, TweetLink, RemoteIP, RemoteUrl, MD5, SHA256",
        "Source":  "https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Threat%20Hunting/TI%20Feed%20-%20TwitterIOCs.md",
        "ResultCount":  0
    }
]

